# Heap Exploitation

Heap exploitation targets vulnerabilities in dynamic memory allocation (malloc/free) and related operations. Techniques range from basic overflows to sophisticated "House of" attacks.

## Table of Contents

- [Ptmalloc2 Fundamentals](#ptmalloc2-fundamentals)
- [Basic Heap Attacks](#basic-heap-attacks)
- [Advanced Heap Attacks](#advanced-heap-attacks)
- [House of Techniques](#house-of-techniques)
- [Heap Mitigation Bypass](#heap-mitigation-bypass)
- [Common Exploitation Primitives](#common-heap-primitives)

## Ptmalloc2 Fundamentals

### Heap Overview

- **Purpose**: Dynamic memory management for efficient allocation/deallocation
- **Key Components**: Chunks, bins (fastbin, unsorted, smallbin, large bin, tcache)
- **Architecture**: Thread-local caching (tcache), Arena-based management

### Heap Structure

**Chunk Layout (glibc 2.31+):**
```
+------------------+
| prev_size | size     |
+------------------+
| user_data  | fd  | bk  |
+------------------+
| next       | ...    |
```

**Flags (2.31+):**
- `PREV_INUSE`: Previous chunk is in use
- `IS_MMAPPED`: Mapped region (mmap, brk, sbrk)
- `NON_MAIN_ARENA`: Not main arena
- `ASLR`: Randomized

**Size Field Encoding:**
- Actual size = size | Last 3 bits are flags (0-7)
- Real size excludes flags, stored as `(size & ~0x7)`

## Ptmalloc2 Implementation

### 基础操作 (Basic Operations)

- `malloc(size)`: Find suitable chunk, split if large
- `free()`: Return chunk to bin, consolidate with adjacent chunks
- `calloc()`: Zero-initialized allocation
- `realloc()`: Resize existing allocation

### 堆初始化 (Heap Initialization)

- **Main Arena**: Created at program start, managed by `main_arena`
- **Thread Arenas**: Per-thread caches (`tcache_perthread_struct`)
- **Top Chunk**: Special chunk marking end of heap region

### 申请内存块 (Malloc Operation)

Algorithm for finding chunk:

1. **Fast bins**: Check fastbins for exact size match
2. **Small bins**: If fastbin empty, search unsorted bin
3. **Large bins**: Search large bin
4. **Unsorted bin**: If no fit, check unsorted bin
5. **System mem**: Use `sbrk` for large allocations

### 释放内存块 (Free Operation)

**Consolidation**: Merge with adjacent freed chunks
- **Placement**: Insert into appropriate bin
- **fd/bk updates**: Maintain chunk linkage

### tcache (Thread Cache) - glibc 2.26+

Per-thread cache of freed chunks:

**Structure:**
```
tcache_perthread_struct:
  - counts[TCACHE_MAX_BINS]
  - entries[TCACHE_MAX_BINS]
```

**Operations:**
- `tcache_put()`: Insert freed chunk into tcache
- `tcache_get()`: Retrieve chunk from tcache by index

**Key Feature:**
- Performance optimization for repeated allocations
- Bypasses unsorted bin size checks
- Per-size bins for fast allocation

## Basic Heap Attacks

### 堆溢出 (Heap Overflow)

**Vulnerability:**
```c
char *a = malloc(0x20);
char *b = malloc(0x20);
strcpy(a, b);  // Overflow from a into b
```

**Detection:**
- Checksec: Binary analysis for unsafe functions (gets, strcpy, sprintf)
- Dynamic: Fuzzing with boundary values

**Exploitation:**
1. Overflow adjacent chunk header
2. Corrupt metadata for next allocation
3. Trigger arbitrary code through heap manipulation

### Off-By-One

**Vulnerability:**
```c
char *a = malloc(0x20);
char *b = malloc(0x21);
read(0, a, 0x21);  // Off-by-one into b's size field
```

**Impact:**
- Changes LSB of adjacent chunk's size
- Can cause chunk overlap
- May trigger fastbin/unsorted bin attack

**Exploitation:**
1. Overwrite adjacent chunk's size to shrink/extend
2. Free and reallocate to overlap
3. Control overlapping chunk memory

### Chunk Extend and Overlapping

**Prerequisites:**
- Overflow into adjacent chunk's size field
- Free adjacent chunk
- Reallocate both chunks to overlap

**Attack Flow:**
1. Allocate chunk A
2. Allocate chunk B adjacent to A
3. Free A
4. Overflow B's size to extend into A
5. Allocate A again with extended size
6. Manipulate free lists to overlap with A

### Unlink Attack

**Legacy Attack** - glibc < 2.28

**Prerequisites:**
- Overflow chunk with UAF payload
- Two adjacent chunks available
- Knowledge of chunk layout

**Attack:**
```python
# Prepare two chunks
a = malloc(0x80)
b = malloc(0x80)

# Overflow to unlink's FD and BK pointers
payload = p32(a + 0x18)  # fd points to target - 0x18
b[0] = p32(b + 0x20)  # bk points to target - 0x20

# Trigger unlink by freeing second chunk
free(a)

# Result: 
# - Unlink removes b from fastbin
# - bk->fd points to a
# - bk->bk points to b+0x18
# - Target chunk a is now unlinked
```

**Mitigation:** glibc 2.28+ checks `fd->bk == P` and `bk->fd == P`

### Use After Free (UAF)

**Technique:**
```c
ptr = malloc(0x80);
read(0, ptr, 8);  // Controlled chunk

free(ptr);

# Chunk A now in tcache/unsorted bin with controlled fd/bk
```

### Fastbin Attack

**Fastbin Structure:**
- Single-linked list (LIFO)
- Size-specific bins (16, 24, 32, 40, ...)

**Attack Flow:**
1. UAF or overflow to modify `fd` pointer
2. Free fastbin chunk
3. Allocation returns controlled chunk

**Constraints:**
- Size must match fastbin size exactly
- `size` field validation (fastbin size check)
- Duplicate free detection (since glibc 2.26+)

**Common Target:**
- **GOT overwrite**: Overwrite function pointer (e.g., printf@GOT)
- **malloc_hook**: Overwrite `__malloc_hook` with shellcode address

### Unsorted Bin Attack

**Unsorted Bin Structure:**
- Circular doubly-linked list
- Contains: FD (forward pointer), BK (backward pointer)

**Attack Techniques:**
1. **Large Bin Attack**: Overwrite `bk` of unsorted bin chunk to large value
2. **Unsorted Bin Leak**: Leak libc addresses via unsorted bin chunks

**Advanced:**
- **House of Orange**: Exploit uninitialized top chunk, trigger libc consolidation
- **House of Force**: Overwrite `top` chunk size to arbitrary value

## Advanced Heap Attacks

### Tcache Poisoning - glibc 2.26+

**Tcache Structure:**
- Per-thread cache entries
- `tcache_perthread_struct`
- `counts[TCACHE_MAX_BINS]`

**Attack Flow:**
1. **Double free**: Free same chunk twice (2.26-27, 2.28+ disabled checks)
2. **Poison**: Allocate chunk, free, reallocate (controlled via `fd`)

**Constraints:**
- Maximum 7 entries per size
- No double-free check in 2.26-27
- Requires controlled `fd` pointer

**Attack Goals:**
- **Arbitrary write**: Overwrite any address in program
- **Code execution**: Overwrite function pointers

### Large Bin Attack

**Large Bin Structure:**
- Sorted doubly-linked list by size

**Attack Flow:**
1. Leak chunk from large bin
2. Overwrite `bk` pointer with target address
3. Free chunk, reallocate controlled chunk

**Constraints:**
- Size must be in large bin range
- Exact size matching

**Common Technique:**
- **House of Orange**: Create fake chunk in unsorted bin, trigger consolidation

## House of Techniques

### House of Force

**Prerequisites:**
- Overflow into top chunk size
- Top chunk not in unsorted bin

**Attack:**
```python
# Overflow top chunk size to large value
# This corrupts heap metadata
# malloc() will return next chunk at wrong offset

# Now manipulate allocation by allocating strategic sizes
sizes = [0x100, 0x200, 0x300, 0x400]
for size in sizes:
    malloc(size)
    free(size)
    # Next allocation returns near corrupted chunk
```

**Impact:**
- Return any address when program calls `malloc()`
- Full heap control via `main_arena`

### House of Lore

**Prerequisites:**
- Target in small bin
- Can manipulate `fd` pointers

**Attack:**
- Trick small bin into unsorted bin shape

### House of Orange

**Prerequisites:**
- No fastbin/small bin chunks available
- Heap uninitialized or partially initialized

**Attack Flow:**
1. Trigger heap consolidation (free two chunks)
2. Create fake chunk in unsorted bin
3. Manipulate unsorted bin's `fd`/`bk`
4. malloc returns fake chunk at controlled address

## Advanced: House of Roman

Combines multiple techniques for advanced exploits.

### House of Pig

**Complex multi-stage attack requiring:**
- Integer overflow + heap overflow
- Format string vulnerabilities
- Multiple heap primitives
- Extensive ROP chain construction

## Heap Mitigation Bypass

| Mitigation | Bypass Technique |
|-----------|----------------|
| NX (No-Execute) | ROP, ret2libc, SROP |
| ASLR | Information leak via GOT/puts/printf, partial overwrite |
| PIE | Leak PIE base, use ROP with relative addresses |
| Stack Canary | Format string leak, brute force, or partial overwrite |
| Safe-linking | Full RELRO bypass via ret2dlresolve |
| Full RELRO | ret2dlresolve, partial RELRO bypass |
| Heap hardening | Tcache poisoning, unsorted bin checks |
| malloc_hook | One-gadget chains (2.32 or 64-bit) |
| free_hook | Similar to malloc_hook, but for free() |
| Fortify Source | _FORTIFY_SOURCE, _FORTIFY_ALL |
| CFI | Control Flow Integrity (CFI) |

## Common Heap Exploitation Primitives

### Information Leak

**Methods:**
1. **Unsorted Bin Leak**: Leak chunk's `fd`/`bk` pointers (libc addresses)
2. **GOT Leak**: Use format string to read GOT entries
3. **Fastbin Leak**: Read stack via `%p`, `%p`, `%x`
4. **Tcache Leak**: Leak tcache entries

### Arbitrary Write

**Methods:**
1. **Unsorted Bin Attack**: Overwrite `bk` pointer in unsorted bin
2. **Large Bin Attack**: Overwrite `bk` in large bin
3. **Tcache Poisoning**: Controlled `fd` via double free

### Control Flow Hijack

**Targets:**
- **GOT entries**: Overwrite function addresses
- **malloc_hook**: Overwrite with one_gadget address
- **free_hook**: Overwrite with shellcode address
- **__realloc_hook**: Manipulate realloc behavior

### Hijack Methods

**Through GOT Overwrite:**
1. Leak libc base address
2. Calculate system() address
3. Overwrite GOT entry (e.g., printf@GOT)
4. Trigger function call → system()

**Through malloc/free_hook:**
1. Find one_gadget in libc (ROPgadget)
2. Allocate shellcode on heap
3. Calculate shellcode address
4. Overwrite `__malloc_hook` with shellcode address

### Example: GOT Overwrite Exploit

```python
from pwn import *

# Step 1: Leak libc base address
conn.sendline(b'%7$s' + p32(printf_got))
leaked = conn.recv(4)
printf_addr = u32(leaked)
libc = ELF('./libc.so.6')
libc.address = printf_addr - libc.symbols['printf']
system_addr = libc.address + libc.symbols['system']

# Step 2: Prepare payload
payload = fmtstr_payload(7, {printf_got: system_addr})
conn.sendline(payload)

# Step 3: Trigger
conn.sendline(b'/bin/sh')
conn.interactive()
```

## Detection

### Static Analysis

**Grep Patterns:**
```bash
# Find unsafe function calls
grep -n "gets(" source.c
grep -n "strcpy(" source.c
grep -n "sprintf(" source.c
grep -n "read(0, buf, len" source.c
```

**Dynamic Analysis:**
- **Fuzzing**: Boundary values, negative values
- **GDB**: Analyze heap layout, monitor free operations
- **Valgrind**: Detect heap corruption (UAF, double free, invalid frees)

### Tools

**Exploitation Frameworks:**
- **pwntools**: `from pwn import *` (ELF, ROP, FormatString, etc.)
- **ROPgadget**: `ROPgadget --binary ./target`
- **one_gadget**: `one_gadget --libc libc.so.6`
- **checksec**: Binary analysis
- **GDB + pwndbg**: Dynamic debugging
- **valgrind**: Memory corruption detection
- **Libc database**: Match libc version to system calls

## Further Resources

- **CTF-Wiki**: Comprehensive heap exploitation documentation
- **how2heap unsorted bin attack**: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unsorted-bin-attack/
- **tcache poisoning**: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/tcache-attack/
- **house of force**: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/
- **how2heap**: https://github.com/ctf-wiki/ctf-wiki/tree/master/docs/pwn/linux/glibc/heap/

## CTF-Wiki Reference Links

The following CTF-Wiki pages contain detailed information:
- Heap fundamentals: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/introduction/
- Heap overview: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-overview/
- Heap structure: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/
- Basic operations: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/basic/
- Malloc/free: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/free/
- Tcache: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/tcache/
- Basic attacks:
  - Heap overflow: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heapoverflow-basic/
  - Off-by-one: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/off-by-one/
  - Chunk extend: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/chunk-extend-overlapping/
  - Unlink: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/
  - UAF: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/use-after-free/
- Fastbin attack: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/
  - Unsorted bin attack: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unsorted-bin-attack/
  - Large bin attack: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/
- Tcache attack: https://ctf-wiki.org/pwn/linux/user-mode/heap/heap/ptmalloc2/tcache-attack/
- House of force: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/
- House of lore: https://ctf-wiki.org/pwn.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-lore/
- House of orange: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-orange/
- House of roman: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-roman/
- House of pig: https://ctf-wiki.org/pwn/linux/user-mode/heap/heap/ptmalloc2/house-of-pig/
