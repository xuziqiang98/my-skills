# Integer Overflow

Integer overflow vulnerabilities occur when arithmetic operations exceed the storage capacity of integer types, causing unexpected behavior in program logic.

## Table of Contents

- [Introduction](#introduction)
- [Exploitation Patterns](#exploitation-patterns)
- [Common Scenarios](#common-scenarios)
- [Mitigations](#mitigations)

## Introduction

### 整数溢出 (Integer Overflow)

Understanding integer overflow vulnerabilities and mechanics.

**Topics:**
- Integer representation (signed vs unsigned)
- Two's complement arithmetic
- Overflow vs underflow
- Wraparound behavior
- Undefined behavior in C

**Types of Integer Vulnerabilities:**
- **Overflow**: Exceeding maximum value (wraps to minimum)
- **Underflow**: Going below minimum value (wraps to maximum)
- **Sign extension**: Mixing signed/unsigned types
- **Truncation**: Casting between different sizes

**Example Overflow:**
```c
unsigned char x = 255;
x = x + 1;  // x becomes 0 (wraps around)

signed char y = 127;
y = y + 1;  // y becomes -128 (wraps around)
```

## Exploitation Patterns

### Unsigned Integer Overflow

Wraparound occurs naturally with unsigned types.

**Vulnerable Pattern:**
```c
// BAD: No bounds checking
void process_data(unsigned int len) {
    char buf[100];
    if (len < 100) {  // Check before overflow
        memcpy(buf, input, len);
    }
}

// Exploit: len = 0xFFFFFFFF
// len + 1 = 0, passes check
// Actual copy: 4GB → buffer overflow
```

**Attack Flow:**
1. Provide large value (near MAX_UINT)
2. Add 1 or perform arithmetic causing wrap
3. Pass bounds check
4. Overflow buffer or cause unexpected behavior

### Signed Integer Overflow

Undefined behavior with signed types.

**Vulnerable Pattern:**
```c
// BAD: Signed integer arithmetic
int read_data(int len) {
    char buf[100];
    if (len > 0 && len < 100) {
        read(fd, buf, len);
    }
}

// Exploit: len = -1 (0xFFFFFFFF)
// -1 > 0 is true
// read() interprets -1 as 4GB (unsigned)
```

**Attack Flow:**
1. Provide negative value (interpreted as large positive)
2. Pass signed check
3. Used as unsigned in actual operation
4. Overflow buffer or read/write arbitrary memory

### Integer Truncation

Casting between integer sizes loses data.

**Vulnerable Pattern:**
```c
// BAD: Truncating size
void process(size_t len) {
    unsigned short real_len = len;  // Truncate to 16 bits
    char buf[real_len];
    // If len > 65535, real_len wraps
    // Allocate small buffer but read large data
}
```

**Attack:**
1. Provide large value (e.g., 0x10001)
2. Truncation reduces to small value (0x0001)
3. Allocation uses small value
4. Read/operation uses large value
5. Buffer overflow or heap corruption

### Sign Extension

Extending signed values unexpectedly.

**Vulnerable Pattern:**
```c
// BAD: Sign extension in indexing
char index = get_index();  // Returns -1 (0xFF)
int array[10];

if (index < 10) {  // -1 extended to 0xFFFFFFFF
    array[index] = 0;  // Array index = -1 → 0xFFFFFFFF
}
```

**Attack:**
1. Provide negative char (0xFF)
2. Sign extension creates large positive int (0xFFFFFFFF)
3. Pass negative check
4. Out-of-bounds memory access

## Common Scenarios

### Buffer Size Calculation

Overflow in size calculation for allocation.

```c
// Vulnerable: size can overflow
unsigned int count, elem_size;
char *buf = malloc(count * elem_size);

// Exploit:
// count = 0x100, elem_size = 0x1000000
// count * elem_size = 0 (overflow)
// malloc(0) allocates small chunk
// memcpy() copies 0x100000000 bytes → overflow
```

### Loop Counters

Overflow in loop conditions.

```c
// Vulnerable: Loop counter overflow
for (int i = 0; i < strlen(user_input); i++) {
    if (i > MAX) break;  // Never hit if i overflows
    process(user_input[i]);
}

// Exploit:
// Provide long input
// i overflows to negative
// Loop continues indefinitely
```

### Offset Calculations

Overflow in pointer arithmetic.

```c
// Vulnerable: offset calculation
char *base = get_base();
unsigned int offset = user_offset;
char *target = base + offset;

// Exploit:
// offset = 0xFFFFFFFF
// base + offset wraps to base - 1
// Access memory before base
```

### Array Indexing

Overflow in array bounds.

```c
// Vulnerable: index not properly validated
char array[256];
int index = get_index();
return array[index];

// Exploit:
// index = 0x100
// Index wraps to 0 in 8-bit arithmetic
// But actual access uses full value
// Out-of-bounds read/write
```

## Combining with Other Vulnerabilities

### Integer Overflow + Stack Overflow

```c
void vulnerable(int len) {
    char buf[100];
    if (len <= 100) {  // Integer overflow: 0x100 + 1 = 0
        read(0, buf, len + 1);
    }
}

// Exploit:
// len = 0x100
// len + 1 = 0x101 (no overflow)
// But len <= 100 check fails
// Need different logic
```

### Integer Overflow + Heap Overflow

```c
char *alloc(int size) {
    return malloc(size);
}

void process(int count) {
    // count = 0x10000000, elem_size = 0x20
    int total = count * elem_size;  // Overflow
    char *buf = alloc(total);  // Small allocation
    read(0, buf, count * elem_size);  // Large read
}

// Exploit: Heap overflow through size calculation overflow
```

### Integer Overflow + Off-by-One

```c
char *buf = malloc(size + 1);  // Size + 1 overflows
// If size = 0xFFFFFFFF, size + 1 = 0
// malloc(0) allocates tiny chunk
// Copy 0xFFFFFFFF bytes → overflow
```

## Detection and Analysis

### Static Analysis

Look for patterns in source code:
- Arithmetic on user-controlled integers
- Casting between signed/unsigned types
- Truncation via size assignments
- Missing bounds checks before operations
- Multiplication in size calculations

**Grep Patterns:**
```bash
# Find potential overflow sites
grep -n "malloc(count \*" source.c
grep -n "read(0, buf, len" source.c
grep -n "memcpy(dst, src, len" source.c
```

### Dynamic Analysis

Fuzzing with boundary values:
- Max values (0xFF, 0xFFFF, 0xFFFFFFFF)
- Off-by-one values
- Negative values in unsigned contexts
- Large multiplication operands

### Tools

- **clang sanitizers**: `-fsanitize=integer`
- **checksec**: Binary analysis for vulnerable functions
- **fuzzers**: AFL, libFuzzer for runtime detection

## Mitigations

### Code-Level

**Validate before arithmetic:**
```c
// GOOD: Check arithmetic
if (a > MAX - b) {
    error("Overflow detected");
}
result = a + b;

// GOOD: Use larger types
uint64_t result = (uint64_t)a * b;
if (result > MAX_UINT32) {
    error("Overflow");
}
```

**Use safe functions:**
```c
// Instead of: memcpy(dst, src, len)
if (len <= dst_size) {
    memcpy(dst, src, len);
}
```

### Compiler Protections

- **-fwrapv**: Defined wraparound behavior
- **-ftrapv**: Trap on overflow
- **Sanitizers**: Runtime overflow detection

### Language-Level

- **Rust**: Safe integer arithmetic by default
- **Python**: Arbitrary precision integers
- **Checked arithmetic libraries**: SafeInt, boost::numeric

## Exploitation Examples

### Example 1: Allocation Overflow

```python
# Vulnerable: size = count * elem_size
# Target: malloc(size) but copy count * elem_size

# Exploit:
count = 0x100
elem_size = 0x1000000
size = count * elem_size  # 0x0, overflow

# malloc(0) - minimal allocation
# But actual copy uses 0x100000000 bytes

# Result: Heap overflow, overwrite adjacent chunks
```

### Example 2: Signed/Unsigned Mismatch

```python
# Vulnerable: signed int used as unsigned
def process(length):
    if length < 0:
        return error
    buf = allocate(length + 1)  # length + 1 wraps
    read_into(buf, length)

# Exploit:
length = -1  # 0xFFFFFFFF
# -1 < 0 check fails
# length + 1 = 0 (signed overflow)
# allocate(0)
# read(0xFFFFFFFF bytes)
```

### Example 3: Truncation Attack

```python
# Vulnerable: size_t -> uint16_t
def copy(data, size):
    real_size = uint16_t(size)  # Truncate to 16 bits
    buf = allocate(real_size)
    memcpy(buf, data, size)  # Use full size

# Exploit:
size = 0x10001
# real_size = 0x0001 (truncated)
# allocate(1)
# memcpy(buf, data, 0x10001)  # Copy 65537 bytes
# Result: Buffer overflow
```

## Further Resources

- **CERT Integer Overflow:** Technical notes on integer handling
- **CWE-190:** Integer Overflow or Wraparound
- **OWASP:** Integer overflow prevention guidelines
- **CTF-Wiki:** Comprehensive examples and theory
