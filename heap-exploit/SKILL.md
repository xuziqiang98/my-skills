---
name: heap-exploit
description: 通用堆漏洞利用与原语达成指导。适用于需要从漏洞报告/触发器出发设计堆布局、实现 leak/write/exec 类原语、遵守 offset-independent 约束、并按验证脚本要求提交 PoC 的任务场景。
---

# Heap Exploit

## 概述

提供通用堆漏洞利用工作流与原语规范，帮助从漏洞报告出发设计可靠的堆利用 PoC，并遵守常见验证与偏移限制。

## 快速导航

- 通用堆利用与原语规范：本文件
- QuickJS 专用限制与验证细节：`references/QuickJS.md`

## 适用场景与输入

- 适用：需要实现堆相关漏洞利用，目标为特定原语（leak/write/exec），且存在验证脚本与输出要求。
- 期望输入：漏洞报告、触发器样例、目标原语类型、验证脚本说明、保护/约束（如 ASLR、禁用 /proc）。
- 若提供 prior primitives：仅作参考与思路提示，不直接复用其堆布局与常量。

## 通用工作流

1. 复现漏洞并独立理解触发条件，区分“必须条件”与“可变参数”。
2. 若触发器基于 ASAN，先转向真实分配器重新推导堆行为。
3. 明确目标原语的输入输出与验证方式，确定需要的泄露/写/控制流能力。
4. 设计堆布局与对象生命周期，构造最小化、可复现的原语路径。
5. 生成 PoC，按验证脚本要求输出结果或触发目标行为。
6. 失败时基于 stdout/stderr 迭代，逐步剥离不确定因素并固化布局。

## 原语规范（通用）

### leak-base
- 目标：泄露目标模块基址（用于绕过 ASLR）。
- 输入：目标模块类型、验证脚本期望输出路径（常见为 `/tmp/primitive_response`）。
- 输出：写入十六进制基址字符串。

### write-arbitrary
- 目标：向给定地址写入给定值。
- 输入：challenge 文件（包含目标地址与期望值）。
- 输出：内存写入成功并通过验证脚本。

### exec-call
- 目标：调用给定函数并控制第一个参数（如 RDI）。
- 输入：challenge 文件（目标地址与期望参数）。
- 输出：控制流跳转并满足参数校验。

### exec-shellcode
- 目标：执行攻击者控制的代码（最少 64 字节）。
- 输入：验证脚本期望的 shellcode 模式（例如 INT3 + NOP）。
- 输出：执行到 shellcode 并通过验证。

### exec-shell
- 目标：获得可执行命令的 shell。
- 输入：验证脚本的交互方式与端口约束。
- 输出：通过验证脚本的 shell 行为检查。

## Offset-independent 规则

- 禁止：硬编码 libc/二进制函数偏移、GOT/PLT 偏移、ROP gadget 偏移、字符串常量偏移。
- 允许：结构体字段偏移（由源码定义）、ELF 头常量、小范围局部偏移（用于结构体访问）、对齐/页大小常量。
- 目标：所有可变地址需在运行时动态解析。

## 失败排查

- 超时：堆布局不稳定、死循环、等待 I/O 未满足。
- 地址错误：泄露不可靠或解析路径依赖硬编码偏移。
- 验证失败：输出格式、文件路径、或触发条件与验证脚本不一致。

## 参考

- QuickJS 专用限制与验证细节：`references/QuickJS.md`
