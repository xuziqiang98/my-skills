{
  "preferences": [
    "在代码审计中，除了传统代码安全漏洞（SQL注入、SSTI、SSRF），还应重点关注业务逻辑漏洞",
    "业务逻辑漏洞需要理解业务流程和权限模型，而非仅依赖污点分析",
    "审计时必须逐项执行检查清单，不能只依赖迭代分析发现",
    "发现的漏洞之间必须做交叉分析，检查是否存在组合放大效应（如慢散列×SQL注入=时序盲注）",
    "每发现一个安全机制，必须反向评估该机制自身能否被武器化",
    "状态机完整性检查：不仅检查「谁有权操作」，还要检查「已完成的操作能否被重复执行」",
    "业务逻辑漏洞完全可以通过静态代码审计发现，不应声称需要动态渗透测试"
  ],
  "fixes": [
    "添加身份认证类漏洞检测：用户枚举、拒绝服务攻击、时序攻击、Host注入",
    "添加CSRF漏洞检测：检查表单是否有CSRF Token验证",
    "添加条件竞争漏洞检测：检查并发操作是否有正确的锁机制",
    "添加完整的数据越权漏洞检测：复购越权、退款越权",
    "添加Web应用特定检测模式：对比用户端和管理员端的安全机制差异",
    "在Phase 3迭代分析后，新增Phase 3.5「跨组件交互分析」：将已发现的漏洞两两配对，分析组合效应",
    "在Phase 2 Sink发现后，新增「防御机制反转检查」：对每个安全机制问「攻击者能否利用此机制攻击其他用户？」",
    "在IDOR检查中新增「幂等性/状态校验」：已支付订单能否再次支付？已退款能否再次退款？状态转换是否有前置条件检查？",
    "在攻击链分析中，必须尝试至少3种组合路径：信息收集→权限提升、IDOR→资金操作、枚举→暴破→接管"
  ],
  "custom_prompts": "审计Web应用时，必须检查以下业务逻辑漏洞：\n\n【基础检查清单】\n1. 用户注册/登录处是否有用户枚举风险（错误消息差异）\n2. 登录失败处理是否有拒绝服务风险（账号锁定逻辑被滥用锁定他人）\n3. 密码哈希是否使用慢散列函数且是否有时序攻击风险（用户存在vs不存在的响应时间差）\n4. 密码找回流程是否有Host注入风险\n5. 管理员登录是否有暴力破解防护\n6. 所有敏感操作（支付、充值、退款、订单修改）是否有CSRF Token\n7. 余额操作是否有条件竞争风险（数据库锁）\n8. 复购、退款等操作是否有正确的用户身份验证\n9. 检查所有IDOR漏洞：收货人、订单、支付等\n10. 对比用户端和管理员端的安全机制差异（如登录失败处理、CSRF保护）\n\n【高阶结构性检查】\n11. 跨组件交互分析：将已发现漏洞两两组合，检查是否存在放大效应（例：慢散列+SQL注入=无需SLEEP的时序盲注；IDOR+缺失状态校验=重复扣款）\n12. 防御机制反转：对每个安全机制（如登录锁定、速率限制、验证码）检查攻击者能否利用该机制对其他用户发起DoS\n13. 状态机完整性：对每个状态变更操作（支付、退款、发货），检查是否有前置状态校验（如if order.status != '已支付'），防止同一操作被重复执行\n14. 幂等性检查：对所有资金变动操作，检查同一请求重复发送N次是否只扣款/充值一次\n15. 攻击链构造（强制）：Phase 5不是可选的。必须尝试组合至少3条攻击链路径，每条路径涉及2+个漏洞的串联",
  "detection_patterns": {
    "用户枚举": "搜索注册/登录接口的错误消息，如'用户已存在'、'账号不存在'等提示词；对比正常和异常情况的响应差异",
    "拒绝服务": "检查登录失败处理逻辑，是否有账号锁定机制导致拒绝服务；对比用户端和管理员端的锁定机制；特别注意：锁定键是基于用户输入(phone/username)还是IP？基于用户输入的锁定=可被攻击者武器化",
    "时序攻击-用户枚举": "检查密码验证函数的控制流：用户存在时是否执行慢操作（如argon2/bcrypt/scrypt哈希），用户不存在时是否快速返回（如except/early return）。差异越大越易利用。关键：不仅检查密码比较本身的时序，更要检查「是否执行哈希」这个宏观分支差异",
    "时序攻击-SQL盲注放大": "如果登录SQL注入存在，且密码验证使用慢散列，则无需SLEEP/BENCHMARK即可实现时序盲注：注入条件为真→返回行→执行argon2(慢)；条件为假→返回空→except(快)。WAF无法通过关键词检测此类攻击",
    "Host注入": "检查密码找回邮件发送代码，是否有Host头部可控；搜索request.host在字符串格式化中的使用",
    "CSRF": "搜索@csrf.exempt、CSRF验证中间件缺失的endpoint；检查所有POST表单是否有csrf_token字段",
    "条件竞争": "检查充值、支付等关键业务是否有数据库事务锁（如SELECT FOR UPDATE）；检查读写操作之间是否存在时间窗口；构造具体业务场景：「一余额多付」「一卡多充」",
    "越权退款": "检查退款接口是否验证当前用户与订单关系；检查order.user_id是否与session匹配",
    "复购越权-重复扣款": "检查支付接口是否验证订单状态（如if order.status != '已支付'）；无状态校验=同一订单可被反复「支付」，每次扣减余额。这不仅是IDOR（谁能操作），更是状态完整性问题（已完成操作能否重做）",
    "CSRF+IDOR组合-支付": "如果支付IDOR存在且无CSRF保护，构造完整攻击场景：攻击者通过IDOR遍历找到受害者订单→修改关联地址→CSRF触发受害者浏览器为该订单付款→受害者花钱，攻击者收货",
    "防御机制反转": "发现安全机制后立即反向分析：登录锁定→能否锁定他人？速率限制→能否耗尽他人配额？验证码→能否阻止他人操作？"
  },
  "vulnerability_taxonomy_additions": [
    {
      "category": "业务逻辑漏洞",
      "subcategories": [
        "用户枚举（注册/登录错误消息差异）",
        "拒绝服务（登录失败账号锁定）",
        "时序攻击（慢散列函数响应时间）",
        "Host注入（密码重置邮件）",
        "CSRF（敏感操作无Token）",
        "条件竞争（并发余额操作）",
        "越权退款",
        "越权复购"
      ]
    },
    {
      "category": "跨组件组合漏洞",
      "subcategories": [
        "慢散列×SQL注入=时序盲注放大",
        "IDOR×CSRF=强制受害者付款",
        "IDOR×缺失状态校验=重复扣款",
        "用户枚举×账号锁定DoS=全站拒绝服务",
        "时序枚举×无暴破防护=账号接管"
      ]
    }
  ],
  "audit_checklist_additions": [
    "□ 检查用户注册/登录的错误消息是否一致（防止枚举）",
    "□ 检查登录失败处理是否有账号锁定机制",
    "□ 检查锁定机制的锁定键是否基于用户输入（如phone）而非IP（基于用户输入=可武器化为DoS）",
    "□ 检查密码哈希函数类型和响应时间",
    "□ 检查密码验证的try/except分支是否在「用户存在」和「用户不存在」路径上有宏观时间差",
    "□ 如果存在SQL注入+慢散列，检查是否可利用散列时间作为布尔盲注的时序Oracle",
    "□ 检查密码找回流程是否有Host头注入",
    "□ 检查管理员登录是否有暴力破解防护",
    "□ 检查所有敏感操作（支付、充值、退款、添加用户）是否有CSRF保护",
    "□ 检查余额操作是否有并发控制（锁机制）",
    "□ 检查复购、退款等操作是否验证用户身份和权限",
    "□ 对比用户端和管理员端的安全机制差异",
    "□ 【状态机检查】对每个状态变更端点，验证是否检查了前置状态（如支付前检查order.status是否为待支付）",
    "□ 【幂等性检查】对每个资金变动端点，验证重复请求是否幂等",
    "□ 【防御反转检查】对每个安全机制，验证攻击者能否利用该机制攻击其他用户",
    "□ 【跨组件交互】将所有已发现漏洞两两配对，检查组合利用可能"
  ],
  "false_negatives_learned": [
    {
      "vulnerability": "SQL注入-登录盲注",
      "found": true,
      "note": "通过污点分析发现"
    },
    {
      "vulnerability": "SQL注入-订单查询",
      "found": true,
      "note": "通过污点分析发现"
    },
    {
      "vulnerability": "SSRF",
      "found": true,
      "note": "通过污点分析发现"
    },
    {
      "vulnerability": "SSTI",
      "found": true,
      "note": "通过污点分析发现"
    },
    {
      "vulnerability": "IDOR-收货人",
      "found": true,
      "note": "通过权限检查发现"
    },
    {
      "vulnerability": "IDOR-订单",
      "found": true,
      "note": "通过权限检查发现"
    },
    {
      "vulnerability": "用户枚举",
      "found": true,
      "note": "初次审计已发现（VULN-17），通过注册接口错误消息差异"
    },
    {
      "vulnerability": "Host注入-密码找回",
      "found": true,
      "note": "初次审计已发现（VULN-07），通过request.host追踪"
    },
    {
      "vulnerability": "账号锁定DoS",
      "found": false,
      "reason": "protect_user_login()的锁定键基于phone参数（用户输入），攻击者可故意输错密码锁定任意用户。审计时将锁定机制视为安全措施而非攻击面",
      "lesson": "【防御机制反转原则】发现任何安全机制后，必须立即反向分析：该机制能否被攻击者用来攻击其他用户？",
      "root_cause": "defense_mechanism_reversal"
    },
    {
      "vulnerability": "时序攻击-慢散列用户枚举",
      "found": false,
      "reason": "valid_user()中用户存在时执行argon2(time_cost=16, ~数秒)，不存在时except立即返回(~毫秒)。初次审计注意到了argon2固定盐值和字符串比较问题，但未分析try/except控制流造成的「是否执行argon2」宏观时序差异",
      "lesson": "【宏观时序分析】不仅关注密码比较的微观时序（字符串==），更要关注「是否执行昂贵操作」的宏观时序。慢散列(argon2/bcrypt/scrypt)的time_cost越高，时序差异越明显",
      "root_cause": "cross_component_interaction"
    },
    {
      "vulnerability": "时序放大SQL盲注",
      "found": false,
      "reason": "SQL注入(VULN-01)和慢散列(VULN-14)分别被识别，但未分析两者的交互效应：SQL注入条件为真→返回行→argon2执行(慢)；条件为假→返回空→except(快)。这将普通布尔盲注升级为无需SLEEP()的时序盲注",
      "lesson": "【跨组件交互原则】发现多个漏洞后，必须检查它们的组合效应。特别是「数据获取漏洞」×「时间放大器」的组合",
      "root_cause": "cross_component_interaction"
    },
    {
      "vulnerability": "管理员时序枚举+暴破组合",
      "found": false,
      "reason": "VULN-19单独指出了管理员暴破防护缺失，但未构造完整攻击链：Phase 1时序枚举用户名→Phase 2暴破密码。两个已知问题的组合形成了完整的管理员接管链",
      "lesson": "【攻击链强制构造】不要满足于单点漏洞列表。Phase 5必须尝试将所有已发现漏洞排列组合，寻找串联利用路径",
      "root_cause": "attack_chain_blindspot"
    },
    {
      "vulnerability": "CSRF支付组合攻击",
      "found": false,
      "reason": "CSRF缺失(VULN-16)和IDOR支付(VULN-12)分别识别，但未构造组合场景：IDOR遍历获取订单→地址篡改→CSRF触发支付→受害者花钱攻击者收货",
      "lesson": "【攻击链强制构造】CSRF+IDOR不是两个独立问题，而是一条完整的资金盗取链",
      "root_cause": "attack_chain_blindspot"
    },
    {
      "vulnerability": "重复支付-状态完整性",
      "found": false,
      "reason": "payment()缺少if order.status != '1'前置检查，已支付订单可被反复「支付」，每次扣减余额。初次审计关注了IDOR（谁能操作），但忽略了状态完整性（操作能否被重复执行）",
      "lesson": "【状态机完整性原则】对每个状态变更操作，不仅检查权限（谁能操作），还要检查前置状态（操作是否合法）和幂等性（重复执行是否安全）",
      "root_cause": "state_completeness"
    },
    {
      "vulnerability": "条件竞争-一余额多付",
      "found": true,
      "note": "初次审计识别了TOCTOU(VULN-13)，但未构造具体业务场景（一余额多付/一卡多充）。技术原理正确但业务利用场景不完整"
    }
  ],
  "root_cause_analysis": {
    "cross_component_interaction": {
      "description": "将多个漏洞/特性作为独立问题分析，未考虑它们的交互和放大效应",
      "missed_vulns": ["时序攻击-慢散列用户枚举", "时序放大SQL盲注"],
      "prevention": "Phase 3完成后，新增Phase 3.5：将所有已发现的漏洞和安全特性两两配对，分析交互效应。特别关注「数据获取漏洞×时间放大器」「权限漏洞×状态漏洞」的组合"
    },
    "defense_mechanism_reversal": {
      "description": "将安全机制视为防御措施而非潜在攻击面，未反向分析其被滥用的可能",
      "missed_vulns": ["账号锁定DoS"],
      "prevention": "发现任何安全机制后，立即执行反转检查：「如果攻击者控制了该机制的输入参数，能否用它攻击其他用户？」"
    },
    "attack_chain_blindspot": {
      "description": "单独识别了各个漏洞，但未系统性构造组合利用路径",
      "missed_vulns": ["管理员时序枚举+暴破组合", "CSRF支付组合攻击"],
      "prevention": "Phase 5攻击链分析必须是强制性的，不是可选的。至少构造3条不同类型的攻击链"
    },
    "state_completeness": {
      "description": "关注了水平越权（谁有权操作）但忽略了状态完整性（操作能否被重复执行）",
      "missed_vulns": ["重复支付-状态完整性"],
      "prevention": "IDOR检查扩展为IDOR+State检查：每个状态变更操作不仅验证权限，还验证前置状态和幂等性"
    }
  },
  "limitations_documented": "code-audit skill的真实局限不是「业务逻辑漏洞需要动态渗透测试」（这是错误的——所有遗漏的漏洞都可从代码静态分析中发现），而是：(1) 跨组件交互分析不足——逐个分析组件时忽略了组合效应；(2) 单向思维——只从「防御」角度看安全机制，未从「攻击」角度反转分析；(3) 攻击链构造被当作可选步骤而非强制步骤",
  "improvement_areas": [
    {
      "area": "强制检查清单执行",
      "issue": "skill已有custom_prompts和audit_checklist，但执行时未逐项检查",
      "solution": "在Phase 1完成后，强制输出检查清单完成状态"
    },
    {
      "area": "对比分析",
      "issue": "用户端和管理员端的安全机制差异未主动对比",
      "solution": "添加对称检查模式：检查用户端和管理员端的同名功能是否有差异"
    },
    {
      "area": "异常分支检查",
      "issue": "只关注正常流程，异常处理分支检查不足",
      "solution": "在Phase 1-2中添加异常处理分支的检查"
    },
    {
      "area": "HTTP头检查",
      "issue": "request.host等HTTP头在业务逻辑中的使用未检查",
      "solution": "在入口点识别后，额外检查HTTP请求头的业务使用"
    },
    {
      "area": "跨组件交互分析（新增Phase 3.5）",
      "issue": "将SQL注入和慢散列作为独立问题分析，未发现两者的时序放大交互",
      "solution": "Phase 3迭代分析完成后，强制执行Phase 3.5：将所有已发现漏洞两两配对，检查组合效应。至少检查：数据获取×时间放大、IDOR×CSRF、枚举×暴破"
    },
    {
      "area": "防御机制反转检查",
      "issue": "登录锁定机制被视为安全措施，未分析其被武器化为DoS的可能",
      "solution": "Phase 2发现安全机制时，自动触发反转分析：「攻击者控制输入参数→能否利用该机制攻击他人？」"
    },
    {
      "area": "状态机完整性检查",
      "issue": "IDOR检查只关注「谁能操作」，忽略「操作能否被重复执行」",
      "solution": "扩展IDOR检查为IDOR+State模式：每个状态变更端点检查权限+前置状态+幂等性"
    },
    {
      "area": "攻击链强制构造",
      "issue": "Phase 5攻击链分析被视为锦上添花，实际上是发现组合漏洞的关键手段",
      "solution": "Phase 5改为强制步骤，必须构造至少3条攻击链。如果构造不出3条，说明分析可能不够深入"
    }
  ],
  "detection_gaps": [
    "错误消息语义分析（用户枚举）",
    "HTTP请求头业务使用（Host注入）",
    "并发控制缺陷（条件竞争）",
    "安全机制对比分析（用户vs管理员）",
    "CSRF保护完整性（全端点检查）",
    "跨组件时序交互（慢散列×SQL注入）",
    "防御机制武器化（锁定DoS）",
    "状态转换完整性（重复操作检查）",
    "攻击链组合盲区（IDOR×CSRF联动）"
  ],
  "structural_evolution_v2": {
    "version": "2.0",
    "date": "2026-03-01",
    "trigger": "pyhackme审计gap analysis: 初次覆盖率59%(10/17)，补充后100%(17/17)",
    "key_insight": "遗漏的7个漏洞中，没有一个是因为「技术能力不足」而遗漏的。全部都是结构性思维盲区：孤立分析组件、单向看待安全机制、将攻击链视为可选。这些需要在skill的核心流程(SKILL.md)中以强制Phase的形式固化",
    "changes_to_skill_md": [
      "新增Phase 3.5「跨组件交互分析」—— 将已发现漏洞两两配对检查组合效应",
      "Phase 2新增「防御机制反转检查」子步骤",
      "Phase 3.3的deep_analyze()新增「状态完整性检查」维度",
      "Phase 5从可选升级为强制，要求最少3条攻击链"
    ]
  }
}
