---
name: code-audit
description: 基于LSP的智能代码安全审计Skill。利用OpenCode内置LSP进行代码理解、符号追踪、数据流分析，Agent自主识别项目特点并执行多维度安全审计（污点分析、认证授权、业务逻辑、敏感信息等），输出可验证的漏洞报告与PoC。适用于任何编程语言和项目类型。
---

# code-audit

> **核心哲学**：不依赖预定义规则匹配，而是指导 Agent 如何利用 LSP 智能理解代码、自主发现漏洞。项目类型无关的通用安全审计。

---

## 1) Skill 概述

### 适用范围（所有项目类型）

| 类别 | 示例 |
|------|------|
| **Web 应用** | HTTP API、WebSocket、GraphQL、微服务 |
| **CLI 工具** | 命令行工具、脚本、构建脚本 |
| **桌面应用** | Electron、Qt、Tkinter、Cocoa |
| **移动应用** | iOS (Swift/Obj-C)、Android (Kotlin/Java)、Flutter、React Native |
| **后端服务** | RPC、gRPC、消息队列消费者、Worker |
| **库/SDK** | 通用库、框架、工具包 |
| **智能合约** | Solidity、Rust (Solana)、Move |
| **嵌入式/系统** | C/C++、Rust、汇编、驱动 |
| **IaC** | Terraform、Pulumi、Helm、Kubernetes YAML |
| **配置/脚本** | Shell、Python、Ruby 脚本 |
| **前端** | React、Vue、Angular、Svelte |
| **混合项目** | 前后端一体 Monorepo |

### 核心目标

- **LSP 驱动的代码理解**：利用符号跳转、引用查找、类型分析理解代码结构
- **Agent 自主判断**：根据项目特点自主识别 source、sink、sanitizer，不依赖规则库
- **项目类型无关**：不预设项目类型，Agent 根据代码自行判断
- **多维度安全审计**：覆盖污点分析、认证授权、业务逻辑、敏感信息、供应链等
- **可验证的漏洞报告**：提供完整的调用链、触发条件、可复现 PoC
- **攻击链组合**：发现单点漏洞间的组合利用路径

### 与 taint-analysis 的区别

| 维度 | taint-analysis | code-audit |
|------|----------------|------------|
| 代码理解 | 正则模式匹配 | LSP 符号追踪 |
| Source/Sink | 预定义规则 | Agent 自主识别 |
| 精准度 | 近似/启发式 | 精确的调用图 |
| 覆盖范围 | 污点分析为主 | 多维度安全审计 |
| PoC | 静态证据 | 可验证的触发条件 |
| 项目类型 | Web 为主 | 全类型通用 |

---

## 2) 触发条件

### Triggers

- 用户要求"做一次代码审计"、"安全审计"、"安全检测"
- 用户要求"审计代码漏洞"、"找出安全问题"
- 用户要求"LSP 审计"、"智能审计"
- 用户要求"审计认证/授权/越权"（指定维度）
- 用户要求"生成漏洞报告"、"输出安全发现"
- 用户要求"审计智能合约"、"审计嵌入式代码"、"审计 IaC"

### Anti-triggers

- 用户只需要单文件 lint/格式化检查
- 用户要求动态渗透测试（非静态审计范畴）
- 用户要求实时漏洞扫描（需要网络访问）

---

## 3) 输入参数

### 必选/默认参数

- `repo_root`: 审计仓库根目录，默认 `.`
- `focus_paths`: 可选，聚焦扫描的目录/文件
- `audit_dimensions`: 审计维度，默认全维度
- `depth`: 追踪深度，默认 `3`

### 可选参数

- `target_languages`: 目标语言，默认自动检测
- `output_format`: 输出格式，`markdown`（默认）/ `json`

---

## 4) 输出产物

### 主要产物（默认 `out/` 目录）

- `out/project_summary.md` - 项目审计概览（包含项目类型识别）
- `out/entry_points.md` - 入口点清单（信任边界）
- `out/sensitive_operations.md` - 敏感操作清单
- `out/flows_traced.md` - 数据流追踪结果
- `out/authz_analysis.md` - 认证授权分析
- `out/findings.md` - 漏洞发现清单
- `out/attack_chains.md` - 攻击链组合
- `out/report.md` - 综合安全审计报告

---

## 5) 核心流程：迭代深入分析

### 核心概念：发现队列 + 迭代深入

**传统扫描**：Phase 1→9 顺序执行一遍 → 结束 → 容易浅尝辄止

**迭代深入**：
1. 基础扫描发现潜在问题
2. 每个问题加入"发现队列"
3. 取出问题 → 深度分析 → 验证 → 可能发现新问题
4. 新问题加入队列 → 继续分析
5. 直到队列为空 → 挖不动为止

```
发现队列 = [初始发现1, 初始发现2, ...]

while 发现队列 not empty:
    当前发现 = 取出最严重的
    深度分析(当前发现)
        → 验证调用链
        → 探索关联问题
        → 如果发现新问题 → 加入队列
    如果没有新进展 → 标记"已挖透"
```

---

### Phase 0: 项目理解（使用 LSP）

**目标**：快速理解项目结构、语言、技术栈、项目类型

**执行步骤**：

1. 使用 `glob` 发现项目根目录的关键文件
2. 识别项目类型：
   - 通过文件后缀判断语言
   - 通过配置文件判断框架/技术栈
   - 通过入口文件判断应用类型
3. 使用 `lsp_symbols` 扫描关键文件，获取函数/类/接口列表
4. 识别项目架构模式

**项目类型识别启发式**：

| 特征 | 可能的类型 |
|------|-----------|
| `package.json`, `node_modules` | Node.js/Web 项目 |
| `Cargo.toml`, `Cargo.lock` | Rust 项目 |
| `go.mod`, `go.sum` | Go 项目 |
| `pom.xml`, `build.gradle` | Java 项目 |
| `requirements.txt`, `setup.py` | Python 项目 |
| `*.sol` | 智能合约 |
| `main.tf`, `*.tfvars` | Terraform IaC |
| `CMakeLists.txt`, `Makefile` | C/C++ 项目 |
| `*.xcodeproj`, `Podfile` | iOS/macOS 项目 |

---

### Phase 1: 入口点发现（信任边界识别）

**目标**：识别所有外部输入入口，定义信任边界

**Agent 思考方式**：

- "这个函数处理什么类型的输入？"
- "输入来自哪里？可信吗？"
- "是否有边界检查/净化？"

**入口类型（按项目类型）**：

| 项目类型 | 入口类型 |
|----------|----------|
| **Web 应用** | HTTP Handler、Router、Middleware、WebSocket、GraphQL Resolver |
| **CLI 工具** | main()、argparse/click flag、stdin 读取 |
| **桌面/移动** | UI 事件回调、文件选择器、URL Scheme |
| **后端服务** | RPC Handler、gRPC Method、MQ Consumer、Webhook |
| **库/SDK** | 公共 API、插件接口、扩展点 |
| **智能合约** | public 函数、receive/payable 函数 |
| **嵌入式** | 中断处理、硬件中断、IO 操作 |
| **IaC** | provider 配置、resource 定义、variable 输入 |

**LSP 追踪**：

```bash
# 从入口函数追踪数据流向
lsp_goto_definition(filePath="src/main.go", line=42, character=15)

# 查找入口函数的所有引用，理解调用链
lsp_find_references(filePath="cmd/root.go", line=100, character=20)
```

---

### Phase 2: 敏感操作识别（Sink 发现）

**目标**：识别所有敏感操作，理解其安全影响

**Agent 思考方式**：

- "这个函数执行什么敏感操作？"
- "操作需要什么权限？"
- "操作的后果是什么？"

**敏感操作分类（项目类型无关）**：

| 类别 | 描述 | 典型 API |
|------|------|----------|
| **命令执行** | 执行系统命令 | exec, spawn, system, Runtime.exec, Command |
| **代码执行** | 动态执行代码/脚本 | eval, exec, new Function, compile |
| **数据库操作** | 原始查询执行 | execute, query, raw, Statement |
| **文件操作** | 读写/删除/执行文件 | open, readFile, writeFile, fopen |
| **网络操作** | 发起 HTTP/网络请求 | http.Get, fetch, axios, socket |
| **加密操作** | 加密/解密/签名 | encrypt, decrypt, sign, verify |
| **认证/授权** | 身份验证/权限检查 | login, authorize, checkPermission |
| **反序列化** | 反序列化外部数据 | pickle.load, yaml.load, ObjectInputStream |
| **进程操作** | 进程创建/管理 | fork, spawn, Process |
| **内存操作** | 内存分配/指针操作 | malloc, memcpy, buffer, unsafe |
| **智能合约** | 合约状态修改 | SSTORE, SLOAD, transfer |

**防御机制反转检查（MANDATORY）**：

在识别到安全机制（如登录锁定、速率限制、验证码、账号冻结）时，**立即执行反转分析**：

```
对于每个安全机制 M：
  1. M 的触发条件是什么？（如：连续5次登录失败）
  2. 触发条件的输入参数是什么？（如：phone/username）
  3. 攻击者能否控制这些输入参数？
  4. 如果能 → 攻击者可以对任意目标用户触发该机制
  5. 触发后的影响是什么？（如：目标用户被锁定15分钟）
  → 如果 3=是 且 5=负面影响 → 该安全机制可被武器化为 DoS
```

**典型反转模式**：

| 安全机制 | 反转攻击 |
|----------|----------|
| 登录失败锁定（基于用户名/手机号） | 攻击者故意输错密码锁定目标账号 |
| 速率限制（基于用户ID） | 攻击者耗尽目标用户的API配额 |
| 验证码触发（基于IP+用户） | 攻击者使目标用户始终需要验证码 |
| 支付冻结（基于异常行为） | 攻击者模拟异常行为冻结目标账户 |
---

### Phase 3: 迭代深入分析（核心）

**这是与传统扫描的核心区别**

#### 3.1 初始发现队列

基础扫描（Phase 1-2）产出的所有潜在问题，加入初始队列：

```
发现队列 = [
  {type: "入口→敏感操作", location: "...", severity: "high"},
  {type: "认证缺失", location: "...", severity: "critical"},
  {type: "硬编码密钥", location: "...", severity: "medium"},
  ...
]
```

#### 3.2 迭代分析循环

```
while 发现队列 not empty:
    # 按严重性排序取出
    当前发现 = pop(发现队列)
    
    # 深度分析
    分析结果 = deep_analyze(当前发现)
    
    # 检查是否有新发现
    for 新问题 in 分析结果.new_findings:
        if 新问题 not in 已分析:
            加入队列(新问题)
    
    # 记录分析深度
    if 分析结果.已挖透:
        标记为"已挖透"
    else:
        放回队列继续
```

#### 3.3 deep_analyze() 具体做什么

对于每个发现，做以下深度分析：

**1. 验证调用链**
- 用 LSP 追踪完整数据流
- 确认每一跳都可定位
- 检查是否有遗漏的中间步骤

**2. 探索关联问题**
- 这个发现附近是否有其他问题？
- 同一个函数是否有多个漏洞？
- 上游/下游是否有关联问题？

**3. 深入验证**
- 检查 Sanitizer 是否有效？是否可绕过？
- 检查 Guard 是否在正确路径？
- 检查是否有漏掉的分支？

**4. 尝试构造完整攻击链**
- 这个漏洞能否与其他漏洞组合？
- 需要什么前置条件？
- 影响面有多大？

**5. 状态完整性检查**
- 该操作是否有前置状态校验？（如 `if order.status != '待支付'`）
- 已完成的操作能否被重复执行？（幂等性）
- 状态转换是否只允许合法路径？（如：待支付→已支付，不允许已支付→已支付）
- 重复执行是否会造成资金/数据影响？（如：每次「支付」都扣余额）

#### 3.4 停止条件

何时停止深入分析一个发现？

- ✅ 调用链已完整，每一步都可定位
- ✅ 所有可能的绕过路径都已检查
- ✅ 已找到上游 Source 或下游 Sink
- ✅ 相邻代码已检查完毕
- ⚠️ 代码复杂度太高，无法继续
- ⚠️ 需要运行时信息才能继续

#### 3.5 跨组件交互分析（MANDATORY）

**在迭代深入分析（Phase 3.1-3.4）完成后，强制执行此步骤。**

**目标**：发现单独分析时不可见的组合漏洞

**执行方式**：

```
所有已发现漏洞 = [V1, V2, V3, ...]
所有安全特性 = [argon2慢散列, 登录锁定, ...]

for (Vi, Vj) in 两两配对(已发现漏洞 + 安全特性):
    问：Vi 是否放大或使能 Vj？
    问：Vj 是否放大或使能 Vi？
    if 存在交互效应:
        记录为新的组合漏洞，加入发现队列
```

**关键交互模式**：

| 组合 | 交互效应 | 示例 |
|------|----------|------|
| 数据获取漏洞 × 时间放大器 | 无需 SLEEP 的时序盲注 | SQL注入 × argon2慢散列：条件为真→执行hash(慢)；条件为假→except(快) |
| IDOR × 缺失 CSRF | 强制受害者操作 | 遍历订单号→篡改地址→CSRF触发受害者付款 |
| 用户枚举 × 无暴破防护 | 完整账号接管链 | 枚举有效用户名→暴力破解密码→登录 |
| IDOR × 缺失状态校验 | 重复资金操作 | 已支付订单可被再次「支付」，每次扣余额 |
| 枚举 × 账号锁定 | 全站拒绝服务 | 枚举所有用户→逐一触发锁定 |

**最少输出**：检查所有 N*(N-1)/2 对组合，记录至少已检查的配对数量和发现的交互数量。

#### 3.6 示例：迭代分析过程

**场景**：发现一个命令注入点
```
第1轮：
  发现：exec.Command(userInput) 在 handler.go:50
  加入队列，severity=critical

第2轮（取出critical）：
  深度分析：
    - 追踪 userInput 来源 → 来自入口参数（request.Body / args[0] / stdin）
    - 检查中间是否有过滤 → 发现 sanitize() 在 L30
    - 检查 sanitize 是否有效 → 发现只过滤分号，可绕过
    - 发现新问题：sanitizer 可绕过！
    - 新发现加入队列

第3轮：
 继续追踪 sanitize() 函数
    - 发现 sanitize 在另一个文件定义
    - 追踪调用者 → 发现有多个调用点
    - 检查其他调用点 → 发现也有问题

第4轮：
  检查 auth 相关
    - 发现这个 endpoint 没有认证
    - 新发现加入队列

第N轮：
  队列中问题都已"挖透"，没有新发现
  → 停止
```

最终产出：
- 1个命令注入（confirmed）
- 1个 sanitizer 可绕过
- 1个认证缺失
- 1个关联漏洞
- 1条攻击链

---

### Phase 4: 漏洞验证与 PoC 生成

**目标**：确保漏洞可触发，提供可验证的 PoC

> **关键原则**：不是只列出"有漏洞"，而是要能回答"漏洞是怎么形成的"和"如何触发"

---

#### 4.1 详细数据流分析（必须）

每个漏洞必须包含**逐跳分析**：

```
Source → H1 → H2 → ... → Sink

每跳都要说明：
- 变量是什么？
- 经过了什么处理？
- 处理是安全的还是危险的？
- 为什么这一跳重要？
```

**示例**（命令注入，适用于 Web/CLI/嵌入式等）：

```
第1跳：入口点
  位置：handler.go:42 或 main.go:30 或 interrupt.c:15
  变量：user_input / args[0] / rx_buffer
  处理：直接赋值/参数传入
  安全性：用户可控/外部输入 ❌
  重要性：入口来源

第2跳：传递
  位置：parser.go:55 或 cmd.go:20
  变量：cmd / command / request
  处理：字符串拼接/格式化
  安全性：未净化 ❌
  重要性：数据传递

第3跳：Sink
  位置：exec.go:118 或 system.c:50
  变量：exec.Command() / system() / subprocess.run()
  处理：系统命令执行
  安全性：危险操作 ⚠️
  重要性：最终执行点

---

#### 4.2 Sanitizer/Guard 分析（必须）

对于每个发现，分析是否有防护：

```
Sanitizer 检查：
- 位置：utils/sanitize.go:30
- 逻辑：过滤了 ; & | 等字符
- 评估：可绕过（只过滤了部分）❌
- 原因：未过滤 `\n` `$(...)` 等

Guard 检查：
- 位置：middleware/auth.go:20
- 逻辑：检查 is_admin
- 评估：有效但路径不覆盖 ✅
- 原因：当前 endpoint 未应用此中间件
```

#### 4.3 PoC 生成（可选）

> 注意：PoC 不是必须的。以下情况可以省略 PoC：
> - 嵌入式/系统级代码（难以模拟运行环境）
> - 智能合约（需要链上环境）
> - 复杂业务逻辑（难以构造触发条件）
> - 权限/越权类问题（需要特定上下文）

如果能提供 PoC，应该是**具体的、可验证的**：

```
### PoC（Web 项目示例）

**请求**：
```http
POST /api/run HTTP/1.1
Host: target.com
Content-Type: application/json

{"cmd": "cat /etc/passwd"}
```

**预期响应**：
```
root:x:0:0:root:/root:/bin/bash
...
```

---

### PoC（CLI 项目示例）
```bash
./app --input "$(cat /etc/passwd)"
```

### PoC（智能合约示例）
```solidity
// 攻击交易
contract.attack({from: attacker, value: 1 ether});
```

### PoC（嵌入式示例）
```c
// 恶意输入触发缓冲区溢出
memcpy(buf, attacker_controlled_input, len);
```

#### 4.3 PoC 生成（可选）

> 注意：PoC 不是必须的。以下情况可以省略 PoC：
> - 嵌入式/系统级代码（难以模拟运行环境）
> - 智能合约（需要链上环境）
> - 复杂业务逻辑（难以构造触发条件）
> - 权限/越权类问题（需要特定上下文）

如果能提供 PoC，应该是**具体的、可验证的**：

#### 4.3 PoC 生成（必须）

PoC 不能是泛泛的示例，必须是**具体的、可验证的**：

```
### PoC

**请求**：
```http
POST /api/run HTTP/1.1
Host: target.com
Content-Type: application/json

{"cmd": "cat /etc/passwd"}
```

**预期响应**：
```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...
```

**触发条件**：
- 无需认证
- Content-Type: application/json
- cmd 参数直接拼接到命令
```

---

#### 4.4 验证步骤

每个漏洞必须验证：

1. **调用链可复现**：用 LSP 确认每跳存在
2. **PoC 可触发**：给出具体的请求/命令
3. **前置条件明确**：需要什么权限/状态
4. **影响范围清晰**：能影响什么

### Phase 5: 攻击链组合（MANDATORY — 不是可选步骤）

**目标**：系统性构造多步攻击链，发现单点分析无法发现的组合利用路径

**强制要求**：必须尝试构造 **至少 3 条** 不同类型的攻击链。如果构造不出 3 条，说明 Phase 3 分析可能不够深入，应回溯重新分析。

**组合模式**：

| 组合类型 | 示例 |
|----------|------|
| 信息收集 → 权限提升 | 信息泄露 → Token → 越权 |
| 弱入口 → 核心漏洞 | SSRF → 内网探测 → RCE |
| 业务逻辑链 | 条件竞争 → 余额篡改 |
| 供应链 | 依赖漏洞 → 代码执行 |
| 智能合约 | 重入 → 资金被盗 |
| 枚举 → 暴破 → 接管 | 时序枚举用户名 → 暴力破解密码 → 管理员接管 |
| IDOR → CSRF → 资金 | 订单遍历 → 地址篡改 → CSRF强制付款 |
| 漏洞 × 防御反转 | 用户枚举 × 锁定机制 → 全站DoS |

**输出格式**（每条攻击链）：

```
攻击链 #N: [名称]
  步骤1: [漏洞A] → 获得 [中间成果]
  步骤2: [漏洞B] → 利用 [中间成果] 达成 [下一步]
  步骤N: [最终影响]
  涉及漏洞: VULN-XX, VULN-YY
  前置条件: [所需权限/状态]
  最终影响: [具体危害]
```
---

### Phase 6: 报告生成

**目标**：输出结构化、可操作的安全报告

---

#### 6.1 报告输出

报告结构：

1. 审计概览（含项目类型）
2. 方法论说明（含迭代分析）
3. 项目发现统计
4. 漏洞详情（按严重性排序）
5. 攻击链分析
6. 修复建议
7. 验证方法

---

#### 6.2 报告验证（重要）

> **在输出最终报告前，必须启动 sub-agent 验证报告有效性**

**验证方式**：

```markdown
请启动一个 sub-agent 验证以下报告：

## 验证任务

请检查刚才生成的漏洞报告，确认：

1. **调用链完整性**：
   - 每个漏洞的调用链是否完整？
   - 每跳是否有具体的文件:行号？
   - 是否存在"跳跃"或跳过的中间步骤？

2. **漏洞真实性**：
   - 漏洞描述是否与代码实际情况一致？
   - 是否有臆测或不确定的地方未标注？

3. **修复建议合理性**：
   - 修复建议是否针对实际问题？
   - 建议的代码是否与当前项目语言/框架匹配？

4. **遗漏检查**：
   - 是否有重要漏洞类型被遗漏？
   - 迭代分析是否"挖到挖不动为止"？

## 输出

请返回：
- 验证通过/需要修改
- 如需修改，具体问题和修改建议
```

**注意**：
- 验证是可选的，但强烈建议执行
- 验证可以发现报告中的遗漏和错误
- 验证后根据反馈修正报告

### Phase 6: 报告生成

**目标**：输出结构化、可操作的安全报告

**报告结构**：

1. 审计概览（含项目类型）
2. 方法论说明（含迭代分析）
3. 项目发现统计
4. 漏洞详情（按严重性排序）
5. 攻击链分析
6. 修复建议
7. 验证方法

## User-Learned Best Practices & Constraints

> **Auto-Generated Section**: This section is maintained by `skill-evolution-manager`. Do not edit manually.

### User Preferences
- 在代码审计中，除了传统代码安全漏洞（SQL注入、SSTI、SSRF），还应重点关注业务逻辑漏洞
- 业务逻辑漏洞需要理解业务流程和权限模型，而非仅依赖污点分析
- 审计时必须逐项执行检查清单，不能只依赖迭代分析发现
- 发现的漏洞之间必须做交叉分析，检查是否存在组合放大效应（如慢散列×SQL注入=时序盲注）
- 每发现一个安全机制，必须反向评估该机制自身能否被武器化
- 状态机完整性检查：不仅检查「谁有权操作」，还要检查「已完成的操作能否被重复执行」
- 业务逻辑漏洞完全可以通过静态代码审计发现，不应声称需要动态渗透测试

### Known Fixes & Workarounds
- 添加身份认证类漏洞检测：用户枚举、拒绝服务攻击、时序攻击、Host注入
- 添加CSRF漏洞检测：检查表单是否有CSRF Token验证
- 添加条件竞争漏洞检测：检查并发操作是否有正确的锁机制
- 添加完整的数据越权漏洞检测：复购越权、退款越权
- 添加Web应用特定检测模式：对比用户端和管理员端的安全机制差异
- 在Phase 3迭代分析后，新增Phase 3.5「跨组件交互分析」：将已发现的漏洞两两配对，分析组合效应
- 在Phase 2 Sink发现后，新增「防御机制反转检查」：对每个安全机制问「攻击者能否利用此机制攻击其他用户？」
- 在IDOR检查中新增「幂等性/状态校验」：已支付订单能否再次支付？已退款能否再次退款？状态转换是否有前置条件检查？
- 在攻击链分析中，必须尝试至少3种组合路径：信息收集→权限提升、IDOR→资金操作、枚举→暴破→接管

### Custom Instruction Injection

审计Web应用时，必须检查以下业务逻辑漏洞：

【基础检查清单】
1. 用户注册/登录处是否有用户枚举风险（错误消息差异）
2. 登录失败处理是否有拒绝服务风险（账号锁定逻辑被滥用锁定他人）
3. 密码哈希是否使用慢散列函数且是否有时序攻击风险（用户存在vs不存在的响应时间差）
4. 密码找回流程是否有Host注入风险
5. 管理员登录是否有暴力破解防护
6. 所有敏感操作（支付、充值、退款、订单修改）是否有CSRF Token
7. 余额操作是否有条件竞争风险（数据库锁）
8. 复购、退款等操作是否有正确的用户身份验证
9. 检查所有IDOR漏洞：收货人、订单、支付等
10. 对比用户端和管理员端的安全机制差异（如登录失败处理、CSRF保护）

【高阶结构性检查】
11. 跨组件交互分析：将已发现漏洞两两组合，检查是否存在放大效应（例：慢散列+SQL注入=无需SLEEP的时序盲注；IDOR+缺失状态校验=重复扣款）
12. 防御机制反转：对每个安全机制（如登录锁定、速率限制、验证码）检查攻击者能否利用该机制对其他用户发起DoS
13. 状态机完整性：对每个状态变更操作（支付、退款、发货），检查是否有前置状态校验（如if order.status != '已支付'），防止同一操作被重复执行
14. 幂等性检查：对所有资金变动操作，检查同一请求重复发送N次是否只扣款/充值一次
15. 攻击链构造（强制）：Phase 5不是可选的。必须尝试组合至少3条攻击链路径，每条路径涉及2+个漏洞的串联